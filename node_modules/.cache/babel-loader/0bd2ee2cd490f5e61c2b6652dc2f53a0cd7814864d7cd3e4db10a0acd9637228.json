{"ast":null,"code":"var _jsxFileName = \"/Users/lee/PycharmProjects/TrafficForecasting/frontend/src/components/NotificationContext.jsx\",\n  _s = $RefreshSig$();\nimport React, { createContext, useState, useEffect } from 'react';\nimport axios from 'axios';\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const NotificationContext = /*#__PURE__*/createContext();\nexport const NotificationProvider = ({\n  children\n}) => {\n  _s();\n  const [notifications, setNotifications] = useState([]);\n  const [modelStatuses, setModelStatuses] = useState({});\n  const pollInterval = 5000; // Poll every 5 seconds\n\n  useEffect(() => {\n    const fetchStatuses = async () => {\n      try {\n        const response = await axios.get('http://127.0.0.1:5000/getModelStatus'); // Endpoint to retrieve all task statuses\n        const updatedStatuses = response.data;\n\n        // Loop through each task and handle based on status\n        const newNotifications = [];\n        const newModelStatuses = {\n          ...modelStatuses\n        };\n        Object.entries(updatedStatuses).forEach(({\n          id,\n          status,\n          message\n        }) => {\n          if (status === 'Good' && newModelStatuses[id] !== 'Good') {\n            newNotifications.push(message);\n            newModelStatuses[id] = 'Good';\n          } else if (status === 'error' && newModelStatuses[id] !== 'error') {\n            newNotifications.push(message);\n            newModelStatuses[id] = 'Failed';\n          } else if (status === 'running') {\n            newModelStatuses[id] = 'Training';\n          }\n        });\n        setNotifications(prev => [...prev, ...newNotifications]);\n        setModelStatuses(newModelStatuses);\n      } catch (error) {\n        console.error(\"Error fetching model statuses:\", error);\n      }\n    };\n    const interval = setInterval(fetchStatuses, pollInterval);\n    fetchStatuses(); // Run immediately on mount\n\n    return () => clearInterval(interval); // Cleanup\n  }, [modelStatuses]);\n  return /*#__PURE__*/_jsxDEV(NotificationContext.Provider, {\n    value: {\n      notifications,\n      setNotifications,\n      modelStatuses\n    },\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 47,\n    columnNumber: 9\n  }, this);\n};\n_s(NotificationProvider, \"xgkYsK0rBpRsQaEt0fdATa/oIwE=\");\n_c = NotificationProvider;\nvar _c;\n$RefreshReg$(_c, \"NotificationProvider\");","map":{"version":3,"names":["React","createContext","useState","useEffect","axios","jsxDEV","_jsxDEV","NotificationContext","NotificationProvider","children","_s","notifications","setNotifications","modelStatuses","setModelStatuses","pollInterval","fetchStatuses","response","get","updatedStatuses","data","newNotifications","newModelStatuses","Object","entries","forEach","id","status","message","push","prev","error","console","interval","setInterval","clearInterval","Provider","value","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["/Users/lee/PycharmProjects/TrafficForecasting/frontend/src/components/NotificationContext.jsx"],"sourcesContent":["import React, { createContext, useState, useEffect } from 'react';\nimport axios from 'axios';\n\nexport const NotificationContext = createContext();\n\nexport const NotificationProvider = ({ children }) => {\n    const [notifications, setNotifications] = useState([]);\n    const [modelStatuses, setModelStatuses] = useState({});\n    const pollInterval = 5000; // Poll every 5 seconds\n\n    useEffect(() => {\n        const fetchStatuses = async () => {\n            try {\n                const response = await axios.get('http://127.0.0.1:5000/getModelStatus'); // Endpoint to retrieve all task statuses\n                const updatedStatuses = response.data;\n\n                // Loop through each task and handle based on status\n                const newNotifications = [];\n                const newModelStatuses = { ...modelStatuses };\n\n                Object.entries(updatedStatuses).forEach(({id, status, message}) => {\n                    if (status === 'Good' && newModelStatuses[id] !== 'Good') {\n                        newNotifications.push(message);\n                        newModelStatuses[id] = 'Good';\n                    } else if (status === 'error' && newModelStatuses[id] !== 'error') {\n                        newNotifications.push(message);\n                        newModelStatuses[id] = 'Failed';\n                    } else if (status === 'running') {\n                        newModelStatuses[id] = 'Training';\n                    }\n                });\n\n                setNotifications((prev) => [...prev, ...newNotifications]);\n                setModelStatuses(newModelStatuses);\n            } catch (error) {\n                console.error(\"Error fetching model statuses:\", error);\n            }\n        };\n\n        const interval = setInterval(fetchStatuses, pollInterval);\n        fetchStatuses(); // Run immediately on mount\n\n        return () => clearInterval(interval); // Cleanup\n    }, [modelStatuses]);\n\n    return (\n        <NotificationContext.Provider value={{ notifications, setNotifications, modelStatuses }}>\n            {children}\n        </NotificationContext.Provider>\n    );\n};"],"mappings":";;AAAA,OAAOA,KAAK,IAAIC,aAAa,EAAEC,QAAQ,EAAEC,SAAS,QAAQ,OAAO;AACjE,OAAOC,KAAK,MAAM,OAAO;AAAC,SAAAC,MAAA,IAAAC,OAAA;AAE1B,OAAO,MAAMC,mBAAmB,gBAAGN,aAAa,CAAC,CAAC;AAElD,OAAO,MAAMO,oBAAoB,GAAGA,CAAC;EAAEC;AAAS,CAAC,KAAK;EAAAC,EAAA;EAClD,MAAM,CAACC,aAAa,EAAEC,gBAAgB,CAAC,GAAGV,QAAQ,CAAC,EAAE,CAAC;EACtD,MAAM,CAACW,aAAa,EAAEC,gBAAgB,CAAC,GAAGZ,QAAQ,CAAC,CAAC,CAAC,CAAC;EACtD,MAAMa,YAAY,GAAG,IAAI,CAAC,CAAC;;EAE3BZ,SAAS,CAAC,MAAM;IACZ,MAAMa,aAAa,GAAG,MAAAA,CAAA,KAAY;MAC9B,IAAI;QACA,MAAMC,QAAQ,GAAG,MAAMb,KAAK,CAACc,GAAG,CAAC,sCAAsC,CAAC,CAAC,CAAC;QAC1E,MAAMC,eAAe,GAAGF,QAAQ,CAACG,IAAI;;QAErC;QACA,MAAMC,gBAAgB,GAAG,EAAE;QAC3B,MAAMC,gBAAgB,GAAG;UAAE,GAAGT;QAAc,CAAC;QAE7CU,MAAM,CAACC,OAAO,CAACL,eAAe,CAAC,CAACM,OAAO,CAAC,CAAC;UAACC,EAAE;UAAEC,MAAM;UAAEC;QAAO,CAAC,KAAK;UAC/D,IAAID,MAAM,KAAK,MAAM,IAAIL,gBAAgB,CAACI,EAAE,CAAC,KAAK,MAAM,EAAE;YACtDL,gBAAgB,CAACQ,IAAI,CAACD,OAAO,CAAC;YAC9BN,gBAAgB,CAACI,EAAE,CAAC,GAAG,MAAM;UACjC,CAAC,MAAM,IAAIC,MAAM,KAAK,OAAO,IAAIL,gBAAgB,CAACI,EAAE,CAAC,KAAK,OAAO,EAAE;YAC/DL,gBAAgB,CAACQ,IAAI,CAACD,OAAO,CAAC;YAC9BN,gBAAgB,CAACI,EAAE,CAAC,GAAG,QAAQ;UACnC,CAAC,MAAM,IAAIC,MAAM,KAAK,SAAS,EAAE;YAC7BL,gBAAgB,CAACI,EAAE,CAAC,GAAG,UAAU;UACrC;QACJ,CAAC,CAAC;QAEFd,gBAAgB,CAAEkB,IAAI,IAAK,CAAC,GAAGA,IAAI,EAAE,GAAGT,gBAAgB,CAAC,CAAC;QAC1DP,gBAAgB,CAACQ,gBAAgB,CAAC;MACtC,CAAC,CAAC,OAAOS,KAAK,EAAE;QACZC,OAAO,CAACD,KAAK,CAAC,gCAAgC,EAAEA,KAAK,CAAC;MAC1D;IACJ,CAAC;IAED,MAAME,QAAQ,GAAGC,WAAW,CAAClB,aAAa,EAAED,YAAY,CAAC;IACzDC,aAAa,CAAC,CAAC,CAAC,CAAC;;IAEjB,OAAO,MAAMmB,aAAa,CAACF,QAAQ,CAAC,CAAC,CAAC;EAC1C,CAAC,EAAE,CAACpB,aAAa,CAAC,CAAC;EAEnB,oBACIP,OAAA,CAACC,mBAAmB,CAAC6B,QAAQ;IAACC,KAAK,EAAE;MAAE1B,aAAa;MAAEC,gBAAgB;MAAEC;IAAc,CAAE;IAAAJ,QAAA,EACnFA;EAAQ;IAAA6B,QAAA,EAAAC,YAAA;IAAAC,UAAA;IAAAC,YAAA;EAAA,OACiB,CAAC;AAEvC,CAAC;AAAC/B,EAAA,CA7CWF,oBAAoB;AAAAkC,EAAA,GAApBlC,oBAAoB;AAAA,IAAAkC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}